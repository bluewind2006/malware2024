https://drive.google.com/drive/folders/1d4zONqADch2K6Hi9kgICXm-7tWEJe6O9?usp=sharing


https://medium.com/@leo.valentic9/malware-unpacking-with-hollows-hunter-and-pe-sieve-redline-stealer-29711da40c8a


4n4lDetector
개발자: 4n0nym0us
설명: 4n4lDetector는 x86 및 x64용 Microsoft Windows 실행 파일, 라이브러리, 드라이버 및 mdump에 대한 분석 도구입니다. 
v1.8부터는 Linux ELF 실행 파일의 이상 현상을 분석하기 위한 확장된 사용도 포함되었습니다.

CAPA
웹: https://github.com/fireeye/capa
개발자: mandiant - www.mandiant.com
설명: Capa는 실행 파일의 기능을 감지합니다. PE, ELF 또는 쉘코드 파일에 대해 이 도구를 실행하면 프로그램이 무엇을 할 수 있다고 생각하는지 알려줍니다. 예를 들어 파일이 백도어이거나, 서비스를 설치할 수 있거나, HTTP를 사용하여 통신한다고 제안할 수 있습니다.


HollowsHunter
개발자: hasherezade
설명: 실행 중인 모든 프로세스를 검사합니다. 
다양한 잠재적 악성 임플란트(교체/이식된 PE, 쉘코드, 후크, 인메모리 패치)를 인식하고 덤프합니다.

PE-sieve
Web: https://github.com/hasherezade/pe-sieve
개발자: hasherezade
설명: PE-sieve는 시스템에서 실행 중인 악성 코드를 탐지하고 추가 분석을 위해 잠재적으로 악성인 자료를 수집하는 데 도움이 되는 도구입니다. 스캔 프로세스 내에서 교체/주입된 PE, 쉘코드, 후크 및 기타 메모리 내 패치 등 다양한 임플란트를 인식하고 덤프합니다. 인라인 후크, Process Hollowing, Process Doppelgänging, Reflective DLL 주입 등을 감지합니다.


FLOSS
Web: https://github.com/fireeye/flare-floss
개발자: mandiant
설명: FLARE Obfuscated String Solver(FLOSS, 이전 FireEye Labs Obfuscated String Solver)는 고급 정적 분석 기술을 사용하여 악성 코드 바이너리에서 문자열을 자동으로 해독합니다. 이를 strings.exe처럼 사용하여 알 수 없는 바이너리에 대한 기본 정적 분석을 향상할 수 있습니다.


QUnpack
개발자: Archer & FEUERRADER
설명: 이 프로그램은 바인더, 크립터, 패커 및 보호기의 동적 압축 풀기를 위한 것입니다. QuickUnpack은 가능한 모든 스크램블러/난독화 장치를 우회하려고 시도하고 리디렉션된 가져오기를 복원합니다. 버전 1부터는 dll을 풀 수 있는 기능이 추가되었습니다. 버전 2에는 QuickUnpack을 덤퍼 및 가져오기 복구 프로그램으로 사용할 수 있는 연결 프로세스 기능이 추가되었습니다. 버전 2에서는 더 복잡한 보호 기능을 풀 수 있는 스크립트도 지원됩니다. 버전 3에서는 x64 지원 및 하드웨어 가상화 디버깅 엔진을 제공했습니다. 이로 인해 QuickUnpack은 세계에서 유사한 유사 제품이 없는 독특한 소프트웨어 제품이 되었습니다!

RL!dePacker (unpack SDK 포함) Oldies라는 추가 기능을 사용하여 사용 가능
웹: http://www.reversinglabs.com
개발자: Ap0x
설명: Reversing Labs RL!dePacker에는 OEP를 감지하는 옵션이 내장되어 있습니다. 그러나 이 옵션은 VB(항상 VB 응용 프로그램에서 FindOEP! 기능을 사용하고 수동 OEP를 강제 실행하시겠습니까?) 및 일부 패커에서는 작동하지 않습니다. 따라서 RL!dePacker가 파일의 압축을 풀 수 없으면 FindOEP를 사용하십시오! 올바른 OEP를 감지하는 기능이지만, 방해가 될 수 있으므로 보조 수단으로만 사용하십시오!
일반 언패커는 IAT 리디렉션을 사용하지 않고 API를 도용하지 않으며 IAT 테이블을 올바른 순서로 채우는 패커만 언팩할 수 있습니다. API 이름으로 변환할 수 있는 서수는 모두 변환되고, 나머지는 IAT에 서수로 삽입됩니다!

MalUnpack
Web: https://github.com/hasherezade/mal_unpack
Developer: hasherezade
Description: Dynamic unpacker based on PE-sieve. It deploys a packed malware, waits for it to unpack the payload, dumps the payload, and kills the original process.


https://berhanbingol.medium.com/virtualbox-detection-anti-detection-eng-54a4cde1b509


/hooks /shellc /data /imp 1
/loop  /imp 1


Unpacking Malware(Selected sample), examining a single process: PE-Sieve
Scanning a full system to detect hidden implants: HollowsHunter
Unpacking a big set of sample: MalUnpack


youtu.be/4Brqslk3ni4   - mimikatz

https://berhanbingol.medium.com/virtualbox-detection-anti-detection-eng-54a4cde1b509
https://securityliterate.com/hiding-virtual-machines-from-malware-introducing-vmwarecloak-vboxcloak/

Projects:

1.) github.com/hfiref0x/VBoxHardenedLoader
2.) github.com/d4rksystem/VBoxCloak (10개월전)
3.) github.com/JayMontana36/vBoxSysInfoMod (6년전)

https://github.com/xyafes/VBoxAntiDetection


1. Basic API Anti-Debugging
I. IsDebuggerPresent()
II. CheckRemoteDebuggerPresent()
III. OutputDebugString()
IV. FindWindow()

2. Advanced API Anti-Debugging
I. NtQueryInformationProcess
II. NtSetInformationThread

3. Timing
I. RDPMC/RDTSC
II. GetLocalTime()
III. GetSystemTime()
IV. GetTickCount()
V. ZwGetTickCount() / KiGetTickCount()
VI. QueryPerformanceCounter()
VII. timeGetTime()

Using Win32 API
1.1. IsDebuggerPresent()
1.2. CheckRemoteDebuggerPresent()
1.3. NtQueryInformationProcess()
1.3.1. ProcessDebugPort
1.3.2. ProcessDebugFlags
1.3.3. ProcessDebugObjectHandle
1.4. RtlQueryProcessHeapInformation()
1.5. RtlQueryProcessDebugInformation()
1.6. NtQuerySystemInformation()

Mitigations(우회방법)
1.1 IsDebuggerPresent() 의 경우 : PEB(프로세스 환경 블록)의 BeingDebugged 플래그를 0으로 설정
1.2 CheckRemoteDebuggerPresent() 및 NtQueryInformationProcess()의 경우 : CheckRemoteDebuggerPresent()가 NtQueryInformationProcess()를 호출하므로 유일한 방법은 NtQueryInformationProcess()를 후크 하고 반환 버퍼에 다음 값을 설정
 -ProcessDebugPort 쿼리의 경우 0(또는 -1을 제외한 모든 값)
-ProcessDebugFlags 쿼리의 경우 0이 아닌 값 .
-ProcessDebugObjectHandle 쿼리의 경우 0 .
3. RtlQueryProcessHeapInformation() , RtlQueryProcessDebugInformation() 및 NtQuerySystemInformation()  경우
- 이를 연결하고 반환된 값을 수정
-RTL_PROCESS_HEAPS::HeapInformation::Heaps[0]:: RtlQueryProcessHeapInformation() 및 RtlQueryProcessDebugInformation() 에 대해 HEAP_GROWABLE 에 플래그를 지정 .
-SystemKernelDebuggerInformation 쿼리 의 경우 NtQuerySystemInformation() 함수에 대해 SYSTEM_KERNEL_DEBUGGER_INFORMATION::DebuggerEnabled를 0으로, SYSTEM_KERNEL_DEBUGGER_INFORMATION::DebuggerNotPresent를 1로 설정.

2. Manual checks
2.1. PEB!BeingDebugged Flag
2.2. NtGlobalFlag
2.3. Heap Flags
2.4. Heap Protection
2.5. Check KUSER_SHARED_DATA structure


https://github.com/hfiref0x/VBoxHardenedLoader
VirtualBox Hardened Loader
VirtualBox Hardened VM detection mitigation loader

“VBOXCLOAK” – HIDING VIRTUALBOX FROM MALWARE

AFAIU, VMware 설정 'hypervisor.cpuid.v0 = "FALSE"'는 게스트의 CPUID 비트 HVP(HyperVisor Present) 를 효과적으로 지웁니다 . 하지만 해당 설정에 대한 실제 문서를 찾지 못했습니다. VirtualBox에서 반가상화 인터페이스를 없음 으로 설정하면 게스트의 CPUID 비트 HVP 도 지워집니다 .

VirtualBox 탐지에 일반적으로 사용되는 맬웨어의 여러 레지스트리 키 이름을 바꿉니다.
VirtualBox 프로세스(VBoxService 및 VBoxTray)를 종료합니다.
VirtualBox 드라이버 파일을 삭제합니다.
System32 디렉터리에서 VirtualBox 지원 파일을 삭제하거나 이름을 바꿉니다.

Pafish
